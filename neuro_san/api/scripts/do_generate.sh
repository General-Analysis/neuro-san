#!/usr/bin/env bash

# Copyright (C) 2023-2024 Cognizant Digital Business, Evolutionary AI.
# All Rights Reserved.
# Issued under the Academic Public License.
#
# You can be released from the terms, and requirements of the Academic Public
# License by purchasing a commercial license.
# Purchase of a commercial license is mandatory for any use of the
# neuro-san SDK Software in commercial settings.
#
# END COPYRIGHT

# This script will:
# 1) Generate GRPC code for any services (generated or not) from its PROTO_FILE
# 2) Modify the code generated by protoc to conform to Python 3
#    by fully specifying package paths for local imports.

# Find out where we are
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Define some directories relative to where we are
# Note: All the protobuf guides say to not mix absolute and relative paths
#       So we pick absolute paths.
ONE_LEVEL_UP=${DIR%/*}
ANOTHER_LEVEL_UP=${ONE_LEVEL_UP%/*}
COMMON_PARENT_DIR=${ANOTHER_LEVEL_UP}
# Up one more directory is the top level
TOP_LEVEL=${ANOTHER_LEVEL_UP%/*}

GENERATED_DIR=neuro_san/api/grpc
PACKAGE="neuro_san.api.grpc"

# Ordering matters w/rt where generated file is output
PROTO_PATH="--proto_path=${TOP_LEVEL}"
echo "PROTO_PATH is ${PROTO_PATH}"

# Inputs to the script
LOCAL_PROTO_FILES=$(< "${DIR}"/protobuf_manifest.txt)

# Where output files go.
PYTHON_OUT=${TOP_LEVEL}


# Requirements:
#   We need to be able to export .proto files from here so they can be
#   protoc-compiled into external projects.
#   We also need to be able to run code in here that references pre-built
#   *_pb2*.py as a standalone library.
#
# Constraints:
#   When exported .proto files from here are used in external projects,
#   protoc-generated python there creates *another* local set of *_pb2*.py files
#   with a serialized version of a *copy* of the original .proto file in
#   its call to _descriptor_pool.Default().AddSerializedFile. When files
#   from both neuro-san and the external project are mixed, this sometimes
#   causes errors in the form of one of 2 errors:
#
#       1)  TypeError: Couldn't build proto file into descriptor pool:
#               Depends on file 'neuro_san/grpc/generated/agent.proto',
#               but it has not been loaded
#       2)  TypeError: Couldn't build proto file into descriptor pool:
#               duplicate symbol 'neuro_san.grpc.generated.agent.AgentStatus'
#
#   These errors arise due to unforgiving naming in the .proto here and unforgiving
#   placement constraints in the directory/package hierarchy.
#   When compiling the .proto file copy, it includes in the description sent to
#   AddSerializedFile() a file path that needs to be both relative to the
#   copied version of the .proto file and the external .proto file that is including
#   it for definitions.
#
#   Because of all this, we end up having to do a couple of things in this repo:
#       1)  .proto files need to live in the same place as where
#           the generated python files end up.
#       2)  Path/package/file names need to be specified from the top level of this repo.
#
#   In the end, any .proto file that is protoc-compiled here needs to come out
#   with the exact same contents of what is passed to AddSerializedFile()
#   when the external project's protoc operation copies and recompiles the .proto
#   file for its own purposes.  Though this isn't really documented anywhere AFAICT,
#   file placement and package naming is tweaked here so that kind of thing can happen
#   more easily in other external repos.

# Note that these files cannot have a service defined in them, otherwise there
# will be problems with references from the _pb2_grpc.py file.
CHANGE_IMPORTS="agent_pb2 \
                chat_pb2 \
                image_data_pb2"


echo "Generating gRPC code in ${GENERATED_DIR}..."

# Create the generated directory if it doesn't exist already
mkdir -p "${GENERATED_DIR}"

# Create a file so that the python compiler can find source in the new dir.
touch "${GENERATED_DIR}"/__init__.py

# Copy over external proto files
ALL_PROTO_FILES=""
ALL_PROTO_FILES="${ALL_PROTO_FILES} ${LOCAL_PROTO_FILES}"


# Generate the python files and make them happy w/rt Python 3
for PROTO_FILE in ${ALL_PROTO_FILES}
do
    PROTO_BASE=$(basename "${PROTO_FILE}")

    # 2) Generate the GRPC code for a single service proto file.
    echo "generating gRPC code for ${PROTO_FILE}."
    # shellcheck disable=SC2086    # PROTO_PATH is compilation of cmd line args
    python -m grpc_tools.protoc ${PROTO_PATH} \
        --python_out="${PYTHON_OUT}" \
        --grpc_python_out="${PYTHON_OUT}" \
        "${PROTO_FILE}"

    echo "Modifying gRPC code for Python 3 for ${PROTO_FILE}"

    # 3) Modify the generated code for fully specified python 3 packages.
    # Derive the file names and import we are looking for from the PROTO_FILE
    GRPC_FILE=${PROTO_BASE/.proto/_pb2_grpc.py}
    PY3_GRPC_FILE=${PROTO_BASE/.proto/_pb2_grpc_py3.py}
    PB2_FILE=${PROTO_BASE/.proto/_pb2.py}
    PY3_PB2_FILE=${PROTO_BASE/.proto/_pb2_py3.py}

    #
    # Change the import of the _pb2 file to have a full python package path.
    #
    IMPORT=${PROTO_BASE/.proto/_pb2}

    # Find the line we want to change with local imports which are no good
    # for py3 and create a new line we want to use with fully-specified imports.
    import_line=$(grep "import ${IMPORT}" < "${GENERATED_DIR}"/"${GRPC_FILE}")
    new_import_line=${import_line/${IMPORT}/${PACKAGE}.${IMPORT}}

    # Create a new file with the new import lines.
    # Note this does not preserve the order of imports,
    # but that's ok.
    echo "$new_import_line" > "${GENERATED_DIR}"/"${PY3_GRPC_FILE}"
    grep -v " ${IMPORT} " < "${GENERATED_DIR}"/"${GRPC_FILE}" >> \
         "${GENERATED_DIR}"/"${PY3_GRPC_FILE}"

    # Move the python3 file into replace the generated file
    mv "${GENERATED_DIR}"/"${PY3_GRPC_FILE}" "${GENERATED_DIR}"/"${GRPC_FILE}"

    for CHANGE_IMPORT in ${CHANGE_IMPORTS}
    do
        #
        # Change the import of the CHANGE_IMPORT file
        # to have a full python package path.
        #
        if [ "${IMPORT}" != "${CHANGE_IMPORT}" ]
        then
            IMPORT=${CHANGE_IMPORT}

            # Find the line we want to change with local imports which are no good
            # for py3 and create a new line we want to use with fully-specified imports.
            import_line=$(grep "import ${IMPORT}" < "${GENERATED_DIR}"/"${GRPC_FILE}")
            new_import_line=${import_line/${IMPORT}/${PACKAGE}.${IMPORT}}

            # Create a new file with the new import lines.
            # Note this does not preserve the order of imports,
            # but that's ok.
            echo "$new_import_line" > "${GENERATED_DIR}"/"${PY3_GRPC_FILE}"
            grep -v " ${IMPORT} " < "${GENERATED_DIR}"/"${GRPC_FILE}" >> \
                "${GENERATED_DIR}"/"${PY3_GRPC_FILE}"

            # Move the python3 file into replace the generated file
            mv "${GENERATED_DIR}"/"${PY3_GRPC_FILE}" "${GENERATED_DIR}"/"${GRPC_FILE}"
        fi

        #
        # Change the import of the CHANGE_IMPORT file
        # to have a full python package path.
        #
        IMPORT=${CHANGE_IMPORT}

        # Find the line we want to change with local imports which are no good
        # for py3 and create a new line we want to use with fully-specified imports.
        import_line=$(grep "import ${IMPORT}" < "${GENERATED_DIR}"/"${PB2_FILE}")
        new_import_line=${import_line/${IMPORT}/${PACKAGE}.${IMPORT}}

        # Create a new file with the new import lines.
        # Note this does not preserve the order of imports,
        # but that's ok.
        echo "$new_import_line" > "${GENERATED_DIR}"/"${PY3_PB2_FILE}"
        grep -v " ${IMPORT} " < "${GENERATED_DIR}"/"${PB2_FILE}" >> \
             "${GENERATED_DIR}"/"${PY3_PB2_FILE}"

        # Move the python3 file into replace the generated file
         mv "${GENERATED_DIR}"/"${PY3_PB2_FILE}" "${GENERATED_DIR}"/"${PB2_FILE}"
    done
done
